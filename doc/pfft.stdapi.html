<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>pfft.stdapi</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/underscore-min.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/jquery.min.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/jquery.cookie.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div>
<div id="explorerclient" class="shaded_box">
</div>
<div id="loadingdoc">Loading...</div>
<div id="content" class="shaded_box">
    <div id="docbody">
        <h2 class="moduletitle">pfft.stdapi</h2>
        <!-- Generated by Ddoc from ../../pfft/stdapi.d -->
<br>

<dl>
<dt><span class="decl">class 
<span class="currsymbol">Fft</span>;
</span></dt>
<dd>A class for calculating discrete fourier transforms using fast fourier
transform. This class mimics std.numeric.
<span class="currsymbol">Fft</span>, but works a bit differently
internally. The 
<span class="currsymbol">Fft</span> in phobos does all the initialization when the
constructor is called. Because pfft uses different tables for each
combination of type and size, it can't do all the initialization up front.
Instead, it calculates a table for a combination of type <code>T</code> and size <i>n</i>
the first time the <code>fft</code> method is called with a template parameter <code>T</code>
and a parameter of size <i>n</i> and then stores this table for later use.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color="#008">import</font> std.stdio, std.conv, std.exception, std.complex;
<font color="#008">import</font> pfft.stdapi;

<font color="#008">void</font> main(string[] args)
{
    <font color="#008">auto</font> n = to!<font color="#008">int</font>(args[1]);

    enforce((n &amp; (n-1)) == 0, <font color="#A31515">"N must be a power of two."</font>);

    <font color="#008">auto</font> f = <font color="#008">new</font> <u>Fft</u>(n);
    <font color="#008">auto</font> data = <u>Fft</u>.allocate!(<font color="#008">double</font>)(n);

    <font color="#008">foreach</font>(<font color="#008">ref</font> e; data)
        readf(<font color="#A31515">"%s %s\n"</font>, &amp;e.re, &amp;e.im);

    <font color="#008">auto</font> ft = f.fft!<font color="#008">double</font>(data);

    <font color="#008">foreach</font>(e; ft)
        writefln(<font color="#A31515">"%s %s"</font>, e.re, e.im);
}
</pre>
<br><br>


<dl>
<dt><span class="decl">this(ulong <span class="funcparam">nmax</span> = 0LU);
</span></dt>
<dd>Fft constructor. <span class="funcparam">nmax</span> is there just for compatibility with std.numeric.Fft.<br><br>

</dd>

<dt><span class="decl">Complex!(T)[] 
<span class="currsymbol">fft</span>(T, R)(R <span class="funcparam">r</span>);
</span></dt>
<dd>Computes  the discrete fourier transform of data in r  and returns it. Data in
r isn't changed. <code>R</code> must be a forward range or a range with a length property.
It must have complex or floating point elements. Here a complex type is a type
with assignable floating point properties <code>re</code> and <code>im</code>. The number of elements
in r must be a power of two. <code>T</code> must be a floating point type. The length
of the returned array is the same as the number of elements in r.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">fft</span>(R, Ret)(R <span class="funcparam">r</span>, Ret <span class="funcparam">ret</span>);
</span></dt>
<dd>Computes the discrete fourier transform of data in r and stores the result in
the user provided buffer ret. Data in r isn't changed. <code>R</code> must be a forward
range or a range with a length property. It must have complex or floating point
elements. Here a complex type is a type with assignable floating point properties
<code>re</code> and <code>im</code>. Ret must be an input range with complex elements. r and ret must
have the same number of elements and that number must be a power of two.<br><br>

</dd>

<dt><span class="decl">Complex!(T)[] 
<span class="currsymbol">inverseFft</span>(T, R)(R <span class="funcparam">r</span>);
</span></dt>
<dd>Computes  the inverse discrete fourier transform of data in r  and returns it.
Data in r isn't changed.  <code>R</code> must be a forward range or a range with a
length property. It must have complex or floating point elements. Here a complex
type is a type with assignable floating point properties <code>re</code> and <code>im</code>. The number
of elements in r must be a power of two. T must be a floating point
type. The length of the returned array is the same as the number of elements in
r.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">inverseFft</span>(R, Ret)(R <span class="funcparam">r</span>, Ret <span class="funcparam">ret</span>);
</span></dt>
<dd>Computes the inverse discrete fourier transform of data in r and stores the
result in the user provided buffer ret. Data in r isn't changed. R must be a
forward range with complex or floating point elements.Here a complex type is
a type with assignable properties <code>re</code> and <code>im</code>. Ret must be an input range with
complex elements. r and ret must have the same number of elements and that
number must be a power of two.<br><br>

</dd>

<dt><span class="decl">T[] 
<span class="currsymbol">allocate</span>(T)(size_t <span class="funcparam">n</span>);
</span></dt>
<dd>Allocates an array of size n aligned appropriately for use as parameters to
<code>fft</code> methods. Both fft methods will still work correctly even if the
parameters are not propperly aligned (or even if they aren't arrays at all),
they will just be a bit slower.<br><br>

</dd>
</dl>
</dd>
</dl>

        <span id="docbody_end"/>
    </div>
</div>
<!--    <div id="docfooter">
            Page was generated with
            <a href="https://github.com/eldar/candydoc"><img src="candydoc/img/logo.png" style="vertical-align:middle; position:relative; top:-1px"></a>
            on Thu Jul 19 07:35:44 2012

        </td>-->
<span id="packages" class="emptytag">
	<span class="emptytag module" modulename="pfft.stdapi"></span>
	<span class="emptytag module" modulename="pfft.pfft"></span>
	<span class="emptytag module" modulename="pfft.clib"></span></span>
</body></html>


